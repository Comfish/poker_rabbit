<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>牌型评估测试</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-case { margin: 20px 0; padding: 10px; border: 1px solid #ccc; }
        .result { margin: 10px 0; padding: 10px; background: #f0f0f0; }
        .correct { color: green; }
        .incorrect { color: red; }
    </style>
</head>
<body>
    <h1>德州扑克牌型评估测试</h1>
    
    <div id="testResults"></div>
    
    <script>
        // 复制核心评估逻辑
        const HAND_RANKS = {
            HIGH_CARD: 0,
            ONE_PAIR: 1,
            TWO_PAIR: 2,
            THREE_OF_A_KIND: 3,
            STRAIGHT: 4,
            FLUSH: 5,
            FULL_HOUSE: 6,
            FOUR_OF_A_KIND: 7,
            STRAIGHT_FLUSH: 8,
            ROYAL_FLUSH: 9
        };
        
        const HAND_NAMES = [
            "高牌",
            "一对",
            "两对",
            "三条",
            "顺子",
            "同花",
            "葫芦",
            "四条",
            "同花顺",
            "皇家同花顺"
        ];
        
        // 辅助函数
        function getSuit(card) { return Math.floor(card / 13); }
        function getRank(card) { return card % 13; }
        
        function countRanks(cards) {
            const counts = new Map();
            for (const card of cards) {
                const rank = getRank(card);
                counts.set(rank, (counts.get(rank) || 0) + 1);
            }
            return counts;
        }
        
        function countSuits(cards) {
            const counts = new Map();
            for (const card of cards) {
                const suit = getSuit(card);
                counts.set(suit, (counts.get(suit) || 0) + 1);
            }
            return counts;
        }
        
        // 检查是否为顺子
        function isStraight(ranks) {
            // 去重并排序
            const uniqueRanks = Array.from(new Set(ranks)).sort((a, b) => a - b);
            
            // 检查A-2-3-4-5的特殊情况
            if (uniqueRanks.includes(12) && 
                uniqueRanks.includes(0) && 
                uniqueRanks.includes(1) && 
                uniqueRanks.includes(2) && 
                uniqueRanks.includes(3)) {
                return true;
            }
            
            // 检查常规顺子
            for (let i = 0; i <= uniqueRanks.length - 5; i++) {
                let isConsecutive = true;
                for (let j = 1; j < 5; j++) {
                    if (uniqueRanks[i + j] !== uniqueRanks[i] + j) {
                        isConsecutive = false;
                        break;
                    }
                }
                if (isConsecutive) {
                    return true;
                }
            }
            
            return false;
        }
        
        // 检查是否为同花
        function isFlush(cards) {
            const suitCounts = countSuits(cards);
            return Array.from(suitCounts.values()).some(count => count >= 5);
        }
        
        // 检查是否为同花顺
        function isStraightFlush(cards) {
            // 按花色分组
            const suitGroups = {};
            for (const card of cards) {
                const suit = getSuit(card);
                if (!suitGroups[suit]) {
                    suitGroups[suit] = [];
                }
                suitGroups[suit].push(card);
            }
            
            // 检查每个花色组
            for (const suitCards of Object.values(suitGroups)) {
                if (suitCards.length >= 5) {
                    // 提取该花色的所有点数
                    const ranks = suitCards.map(getRank);
                    if (isStraight(ranks)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // 检查是否为皇家同花顺
        function isRoyalFlush(cards) {
            // 按花色分组
            const suitGroups = {};
            for (const card of cards) {
                const suit = getSuit(card);
                if (!suitGroups[suit]) {
                    suitGroups[suit] = [];
                }
                suitGroups[suit].push(card);
            }
            
            // 检查每个花色组
            for (const suitCards of Object.values(suitGroups)) {
                if (suitCards.length >= 5) {
                    // 提取该花色的所有点数
                    const ranks = suitCards.map(getRank);
                    const hasTen = ranks.includes(8);
                    const hasJack = ranks.includes(9);
                    const hasQueen = ranks.includes(10);
                    const hasKing = ranks.includes(11);
                    const hasAce = ranks.includes(12);
                    
                    if (hasTen && hasJack && hasQueen && hasKing && hasAce) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // 生成组合（从n个元素中选择k个）
        function getCombinations(arr, k) {
            const result = [];
            
            function combine(temp, start) {
                if (temp.length === k) {
                    result.push([...temp]);
                    return;
                }
                for (let i = start; i < arr.length; i++) {
                    temp.push(arr[i]);
                    combine(temp, i + 1);
                    temp.pop();
                }
            }
            
            combine([], 0);
            return result;
        }
        
        // 评估5张牌的牌型
        function evaluateFiveCardHand(cards) {
            const ranks = cards.map(getRank);
            const suits = cards.map(getSuit);
            
            const rankCounts = countRanks(cards);
            const suitCounts = countSuits(cards);
            
            // 准备用于比较的牌型信息
            const handInfo = {
                rank: HAND_RANKS.HIGH_CARD,
                kickers: []
            };
            
            // 转换rankCounts为排序后的数组：[点数, 出现次数]，按出现次数和点数排序
            const sortedRankEntries = Array.from(rankCounts.entries())
                .sort((a, b) => {
                    // 先按出现次数降序
                    if (b[1] !== a[1]) {
                        return b[1] - a[1];
                    }
                    // 再按点数降序
                    return b[0] - a[0];
                });
            
            // 生成排序后的点数数组，用于比较
            const sortedRanks = Array.from(rankCounts.keys()).sort((a, b) => b - a);
            
            // 检查皇家同花顺
            if (isRoyalFlush(cards)) {
                handInfo.rank = HAND_RANKS.ROYAL_FLUSH;
            } 
            // 检查同花顺
            else if (isStraightFlush(cards)) {
                handInfo.rank = HAND_RANKS.STRAIGHT_FLUSH;
                // 同花顺的大小由最大的牌决定
                handInfo.kickers = sortedRanks;
            } 
            // 检查四条
            else if (sortedRankEntries[0][1] === 4) {
                handInfo.rank = HAND_RANKS.FOUR_OF_A_KIND;
                handInfo.kickers = [sortedRankEntries[0][0], sortedRankEntries[1][0]];
            } 
            // 检查葫芦
            else if (sortedRankEntries[0][1] === 3 && sortedRankEntries[1][1] === 2) {
                handInfo.rank = HAND_RANKS.FULL_HOUSE;
                handInfo.kickers = [sortedRankEntries[0][0], sortedRankEntries[1][0]];
            } 
            // 检查同花
            else if (isFlush(cards)) {
                handInfo.rank = HAND_RANKS.FLUSH;
                handInfo.kickers = sortedRanks;
            } 
            // 检查顺子
            else if (isStraight(ranks)) {
                handInfo.rank = HAND_RANKS.STRAIGHT;
                handInfo.kickers = sortedRanks;
            } 
            // 检查三条
            else if (sortedRankEntries[0][1] === 3) {
                handInfo.rank = HAND_RANKS.THREE_OF_A_KIND;
                handInfo.kickers = [sortedRankEntries[0][0], ...sortedRanks.filter(r => r !== sortedRankEntries[0][0])];
            } 
            // 检查两对
            else if (sortedRankEntries[0][1] === 2 && sortedRankEntries[1][1] === 2) {
                handInfo.rank = HAND_RANKS.TWO_PAIR;
                const pair1 = sortedRankEntries[0][0];
                const pair2 = sortedRankEntries[1][0];
                const kicker = sortedRanks.find(r => r !== pair1 && r !== pair2);
                handInfo.kickers = [pair1, pair2, kicker];
            } 
            // 检查一对
            else if (sortedRankEntries[0][1] === 2) {
                handInfo.rank = HAND_RANKS.ONE_PAIR;
                const pair = sortedRankEntries[0][0];
                const kickers = sortedRanks.filter(r => r !== pair);
                handInfo.kickers = [pair, ...kickers];
            } 
            // 高牌
            else {
                handInfo.rank = HAND_RANKS.HIGH_CARD;
                handInfo.kickers = sortedRanks;
            }
            
            return handInfo;
        }
        
        // 从所有5张牌组合中选择最佳牌型
        function evaluateHand(cards) {
            let bestHand = {
                rank: HAND_RANKS.HIGH_CARD,
                kickers: []
            };
            
            // 生成所有可能的5张牌组合
            const combinations = getCombinations(cards, 5);
            
            // 评估每个组合的牌型
            for (const combo of combinations) {
                const currentHand = evaluateFiveCardHand(combo);
                if (compareHands(currentHand, bestHand) > 0) {
                    bestHand = currentHand;
                }
            }
            
            return bestHand;
        }
        
        // 比较两手牌的大小
        function compareHands(hand1, hand2) {
            // 先比较牌型等级
            if (hand1.rank > hand2.rank) {
                return 1;
            } else if (hand1.rank < hand2.rank) {
                return -1;
            }
            
            // 牌型相同，比较kickers
            for (let i = 0; i < Math.min(hand1.kickers.length, hand2.kickers.length); i++) {
                if (hand1.kickers[i] > hand2.kickers[i]) {
                    return 1;
                } else if (hand1.kickers[i] < hand2.kickers[i]) {
                    return -1;
                }
            }
            
            // 所有kickers都相同，平局
            return 0;
        }
        
        // 辅助函数：将牌字符串转换为编码
        function cardStrToCode(cardStr) {
            const suits = { '♠': 0, '♥': 1, '♦': 2, '♣': 3 };
            const ranks = { '2': 0, '3': 1, '4': 2, '5': 3, '6': 4, '7': 5, '8': 6, '9': 7, 'T': 8, 'J': 9, 'Q': 10, 'K': 11, 'A': 12 };
            
            const rank = cardStr.substring(0, 1);
            const suit = cardStr.substring(1, 2);
            
            return ranks[rank] + suits[suit] * 13;
        }
        
        // 测试函数
        function runTest(description, holeCardsStr, communityCardsStr, expectedBestHand, expectedRankName) {
            const holeCards = holeCardsStr.map(cardStrToCode);
            const communityCards = communityCardsStr.map(cardStrToCode);
            const allCards = [...holeCards, ...communityCards];
            
            const bestHand = evaluateHand(allCards);
            const rankName = HAND_NAMES[bestHand.rank];
            
            const resultDiv = document.createElement('div');
            resultDiv.className = 'test-case';
            
            let testStatus = '';
            if (bestHand.rank === expectedBestHand && rankName === expectedRankName) {
                testStatus = '<span class="correct">✓ PASS</span>';
            } else {
                testStatus = `<span class="incorrect">✗ FAIL</span><br>Expected: ${expectedRankName} (${expectedBestHand}), Got: ${rankName} (${bestHand.rank})`;
            }
            
            resultDiv.innerHTML = `
                <h3>${description}</h3>
                <p>手牌: ${holeCardsStr.join(', ')}</p>
                <p>公共牌: ${communityCardsStr.join(', ')}</p>
                <p>最佳牌型: ${rankName}</p>
                <div class="result">${testStatus}</div>
            `;
            
            document.getElementById('testResults').appendChild(resultDiv);
        }
        
        // 运行测试用例
        function runAllTests() {
            // 测试用例1: A♠A♥ + K♦Q♦J♦T♦ (当前最佳牌型)
            runTest(
                "测试用例1: 口袋对A + 4张同花顺听牌",
                ['A♠', 'A♥'],
                ['K♦', 'Q♦', 'J♦', 'T♦'],
                HAND_RANKS.ONE_PAIR,
                "一对"
            );
            
            // 测试用例2: A♠A♥ + K♦Q♦J♦T♦A♦ (完成同花顺)
            runTest(
                "测试用例2: 口袋对A + 5张同花顺",
                ['A♠', 'A♥'],
                ['K♦', 'Q♦', 'J♦', 'T♦', 'A♦'],
                HAND_RANKS.ROYAL_FLUSH,
                "皇家同花顺"
            );
            
            // 测试用例3: A♠A♥ + K♦Q♦J♦T♦9♦ (完成顺子)
            runTest(
                "测试用例3: 口袋对A + 5张顺子",
                ['A♠', 'A♥'],
                ['K♦', 'Q♦', 'J♦', 'T♦', '9♦'],
                HAND_RANKS.STRAIGHT,
                "顺子"
            );
            
            // 测试用例4: A♠A♥ + K♦Q♦J♦T♦A♣ (完成三条)
            runTest(
                "测试用例4: 口袋对A + 5张公共牌含A",
                ['A♠', 'A♥'],
                ['K♦', 'Q♦', 'J♦', 'T♦', 'A♣'],
                HAND_RANKS.THREE_OF_A_KIND,
                "三条"
            );
            
            // 测试用例5: 3♥4♥ + 5♥6♥6♦6♣ (三条 + 同花听牌)
            runTest(
                "测试用例5: 连牌 + 三条 + 同花听牌",
                ['3♥', '4♥'],
                ['5♥', '6♥', '6♦', '6♣'],
                HAND_RANKS.THREE_OF_A_KIND,
                "三条"
            );
            
            // 测试用例6: 3♥4♥ + 5♥6♥6♦6♣7♥ (完成同花)
            runTest(
                "测试用例6: 连牌 + 三条 + 完成同花",
                ['3♥', '4♥'],
                ['5♥', '6♥', '6♦', '6♣', '7♥'],
                HAND_RANKS.FLUSH,
                "同花"
            );
        }
        
        // 页面加载时运行测试
        window.onload = runAllTests;
    </script>
</body>
</html>